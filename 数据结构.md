# 1、数据结构和算法概述

## 1.1、数据结构和算法的关系

1.  数据 data 结构(structure)是一门研究组织数据方式的学科，有了编程语言也就有了数据结构.学好数据结构可以 编写出更加漂亮,更加有效率的代码。
2. 要学习好数据结构就要多多考虑如何将生活中遇到的问题,用程序去实现解决。
3.  程序 = 数据结构 + 算法
4. 数据结构是算法的基础, 换言之，想要学好算法，需要把数据结构学到位。

1.2、线性结构和非线性结构

数据结构包括：线性结构和非线性结构

### 1.2.1、线性结构

1. 线性结构作为最常用的数据结构，其特点是**数据元素之间存在一对一的线性关系** 
2. 线性结构有两种不同的存储结构，即**顺序存储结构(数组)和链式存储结构(链表)**。顺序存储的线性表称为顺序 表，**顺序表中的存储元素是连续的**
3.  链式存储的线性表称为链表，链表中的**存储元素不一定是连续的**，元素节点中存放数据元素以及相邻元素的地址信息 
4. 线性结构常见的有：**数组、队列、链表和栈**，后面我们会详细讲解.

### 1.2.2、非线性结构

非线性结构包括：二维数组、多维数组、广义表、**树结构、图结构**

# 2、稀疏数组和队列

## 2.1、稀疏数组

### 2.1.1、先看一个实际需求

编写五子棋程序中，有存盘和续上盘的功能

![image-20210710220217327](C:\Users\pz\AppData\Roaming\Typora\typora-user-images\image-20210710220217327.png)



分析问题

因为该二维数组的很多值是默认值0，因此记录了很多没有意义的数据

### 2.1.2、基本介绍

当一个数组中大部分元素为０，或者为同一个值的数组时，可以使用稀疏数组来保存该数组。    



稀疏数组的处理方法是:

1. 记录数组一共有几行几列，有多少个不同的值
2. 把具有不同值的元素的行列及值记录在一个小规模的数组中，从而缩小程序的规模

![image-20210710220446916](C:\Users\pz\AppData\Roaming\Typora\typora-user-images\image-20210710220446916.png)



### 2.1.3、应用实例

1. 使用稀疏数组，来保留类似前面的二维数组(棋盘、地图等等)
2. 把稀疏数组存盘，并且可以从新恢复原来的二维数组数
3. 整体思路分析



![image-20210710220615796](C:\Users\pz\AppData\Roaming\Typora\typora-user-images\image-20210710220615796.png)



```
1. 遍历原始的二维数组，得到有效数据的个数sum
2. 根据sum就可以创建稀疏数组sparseArr int[sum+1][3]
3. 将二维数组的有效数据存入到稀疏数组

稀疏数组转原始的二维数组的思路

1. 先读取稀疏数组的第一行，根据第一行的数据，创建原始的二维数组，比如上面的chessArr=int[11][11]
2. 在读取稀疏数组后几行的数据，并赋给原始的二维数组即可
```

4. 代码实现

```java
public class SparseArray {
    public static void main(String[] args) {
        //先创建一个原始的二维数组 11*11
        //0:表示没有棋子，1：表示黑子，2：表示白子
        int row = 11;
        int column = 11;
        int[][] chessArr1 = new int[row][column];
        chessArr1[1][2] = 1;
        chessArr1[2][3] = 2;
        chessArr1[3][4] = 2;

        //输出原始的二维数组
        System.out.println("输出原始的二维数组");
        for (int[] rows : chessArr1) {
            for (int data : rows) {
                System.out.print(data + "\t");
            }
            System.out.println();
        }
        //将二维数组转换为稀疏数组
        //先遍历二维数组，得到非0数据的个数
        int sum = 0;
        for (int[] rows : chessArr1) {
            for (int data : rows) {
                if (data != 0)
                    sum++;
            }
        }
        System.out.println("sum:" + sum);
        //创建对应的稀疏数组
        int[][] sparseArr = new int[sum + 1][3];
        //给稀疏数组赋值
        sparseArr[0][0] = 11;
        sparseArr[0][1] = 11;
        sparseArr[0][2] = sum;
        //遍历二维数组，将非0的值存放到sparseArr中
        int count = 0;//count用于记录是第几个非0的数据
        for (int i = 0; i < row; i++) {
            for (int j = 0; j < column; j++) {
                if (chessArr1[i][j] != 0) {
                    count++;
                    sparseArr[count][0] = i;
                    ;
                    sparseArr[count][1] = j;
                    ;
                    sparseArr[count][2] = chessArr1[i][j];
                }
            }
        }
        //输出稀疏数组的形式
        System.out.println();
        System.out.println("得到稀疏数组为~~~~");
        for (int i = 0; i < sparseArr.length; i++) {
            System.out.printf("%d\t%d\t%d\t\n", sparseArr[i][0], sparseArr[i][1], sparseArr[i][2]);
        }

        //将稀疏数组恢复成二维数组
        //1. 先读取稀疏数组的第一行，根据第一行的数据，创建原始的二维数组，比如上面的chessArr=int[11][11]
        //2. 在读取稀疏数组后几行的数据，并赋给原始的二维数组即可
        System.out.println();
        //先读取稀疏数组的第一行，根据第一行的数据，创建原始的二维数组
        int[][] chessArr2 = new int[sparseArr[0][0]][sparseArr[0][1]];
        //在读取稀疏数组后几行的数据，并赋给原始的二维数组即可
        for (int i=1;i<sparseArr.length;i++){
            for (int j=0;j<3;j++){
                chessArr2[sparseArr[i][0]][sparseArr[i][1]]=sparseArr[i][2];
            }
        }
        // 输出恢复后的二维数组
        System.out.println();
        System.out.println("输出恢复后的二维数组");
        for (int i = 0; i < row; i++) {
            for (int j = 0; j < column; j++) {
                System.out.print(chessArr2[i][j] + "\t");
            }
            System.out.println();
        }
    }
}
```

## 2.3、队列

### 2.3.1、队列介绍

1. 队列是一个**有序列表**，可以用数组或是**链表**来实现。
2. 遵循**先入先出**的原则。即：**先存入队列的数据，要先取出。后存入的要后取出**
3. 示意图：(使用数组模拟队列示意图)

![image-20210711161915191](C:\Users\pz\AppData\Roaming\Typora\typora-user-images\image-20210711161915191.png)



### 2.3.2、数组模拟队列思路

- 队列本身是有序列表，若使用数组的结构来存储队列的数据，则队列数组的声明如下图, 其中 maxSize 是该队 列的最大容量。
- 因为队列的输出、输入是分别从前后端来处理，因此需要两个变量 front 及 rear 分别记录队列前后端的下标， front 会随着数据输出而改变，而 rear 则是随着数据输入而改变，如图所示

![image-20210711161915191](C:\Users\pz\AppData\Roaming\Typora\typora-user-images\image-20210711161915191.png)

- 当我们将数据存入队列时称为”addQueue”，addQueue 的处理需要有两个步骤：思路分析
  1. 将尾指针往后移：rear+1 , 当 front == rear 【空】
  2. 若尾指针 rear 小于队列的最大下标 maxSize-1，则将数据存入 rear 所指的数组元素中，否则无法存入数据。 rear == maxSize【队列满】

#### 代码实现

```java
//用数组模拟队列，编写一个ArrayQueue
class ArrayQueue{
    private int maxSize;//表示数组的最大容量
    private int front;//队列头
    private int rear;//队列尾
    private int[] arr;//该数组用于存放数据,模拟队列
    // 创建队列的构造器
    public ArrayQueue(int maxSize) {
        this.maxSize = maxSize;
        this.arr = new int[maxSize];
        this.front = -1;//指向队列头部，分析出 front 是指向队列头的前一个位置
        this.rear = -1;//指向队列尾，指向队列尾的数据(即就是队列最后一个数据)
    }
    //判断队列是否满
    public boolean isFull(){
        return rear == maxSize-1;
    }
    //判断队列是否为空
    public boolean isEmpty(){
        return rear == front;
    }
    //添加数据到队列
    public void addQueue(int n){
        // 判断队列是否满
        if(isFull()){
            System.out.println("队列满，不能加入数据~");
            return;
        }
        rear++;
        arr[rear] = n;
    }
    //获取队列的数据，出队列
    public int getQueue(){
        //判断队列是否为空
        if (isEmpty()){
            throw new RuntimeException("队列空，不能取数据");
        }
        front++;
        return arr[front];
    }
    //显示队列的所以数据
    public void showQueue(){
        //判断队列是否为空
        if (isEmpty()){
            System.out.println("队列空的，没有数据~~");
            return;
        }
        for (int i = 0; i < arr.length; i++) {
            System.out.println("arr["+i+"]="+arr[i]);
        }
    }
    //显示队列的头数据，注意不是取出数据
    public int headQueue(){
        //判断队列是否为空
        if (isEmpty()){
            throw new RuntimeException("队列空的，没有数据~~");
        }
        return arr[front + 1];
    }
}
```

#### 测试代码

```java
public static void main(String[] args) {
        //测试一把
        //创建一个队列
        ArrayQueue queue = new ArrayQueue(3);
        char key = ' '; //接收用户输入
        Scanner scanner = new Scanner(System.in);//
        boolean loop = true;
        //输出一个菜单
        while(loop) {
            System.out.println("s(show): 显示队列");
            System.out.println("e(exit): 退出程序");
            System.out.println("a(add): 添加数据到队列");
            System.out.println("g(get): 从队列取出数据");
            System.out.println("h(head): 查看队列头的数据");
            key = scanner.next().charAt(0);//接收一个字符
            switch (key) {
                case 's':
                    queue.showQueue();
                    break;
                case 'a':
                    System.out.println("输出一个数");
                    int value = scanner.nextInt();
                    queue.addQueue(value);
                    break;
                case 'g': //取出数据
                    try {
                        int res = queue.getQueue();
                        System.out.printf("取出的数据是%d\n", res);
                    } catch (Exception e) {
                        // TODO: handle exception
                        System.out.println(e.getMessage());
                    }
                    break;
                case 'h': //查看队列头的数据
                    try {
                        int res = queue.headQueue();
                        System.out.printf("队列头的数据是%d\n", res);
                    } catch (Exception e) {
                        // TODO: handle exception
                        System.out.println(e.getMessage());
                    }
                    break;
                case 'e': //退出
                    scanner.close();
                    loop = false;
                    break;
                default:
                    break;
            }
        }
        System.out.println("程序退出~~");
    }
```

### 2.3.3、数组模拟环形队列

对前面的数组模拟队列的优化，充分利用数组. 因此将数组看做是一个环形的。(**通过取模的方式来实现即可**)

#### 分析说明

1. 尾索引的下一个为头索引时表示队列满，即将队列容量空出一个作为约定,这个在做判断队列满的 时候需要注意 (rear + 1) % maxSize == front 满
2. rear == front
3.  分析示意图

![image-20210715222359902](C:\Users\pz\AppData\Roaming\Typora\typora-user-images\image-20210715222359902.png)

#### 代码实现

```java
class CircleArray {
    private int maxSize; // 表示数组的最大容量
    /*
    front 变量的含义做一个调整： front 就指向队列的第一个元素, 也就是说 arr[front] 就是队列的第一个元素
    front 的初始值 = 0
    */
    private int front;
    /*
    rear 变量的含义做一个调整：rear 指向队列的最后一个元素的后一个位置. 因为希望空出一个空间做为约定.
    rear 的初始值 = 0
    */
    private int rear; // 队列尾
    private int[] arr; // 该数据用于存放数据, 模拟队列

    public CircleArray(int arrMaxSize) {
        maxSize = arrMaxSize;
        arr = new int[maxSize];
        front = 0;
        rear = 0;
    }
    // 判断队列是否满
    public boolean isFull() {
        return (rear  + 1) % maxSize == front;
    }

    // 判断队列是否为空
    public boolean isEmpty() {
        return rear == front;
    }

    // 添加数据到队列
    public void addQueue(int n) {
        // 判断队列是否满
        if (isFull()) {
            System.out.println("队列满，不能加入数据~");
            return;
        }
        //直接将数据加入
        arr[rear] = n;
        //将 rear 后移, 这里必须考虑取模
        rear = (rear + 1) % maxSize;
    }

    // 获取队列的数据, 出队列
    public int getQueue() {
        // 判断队列是否空
        if (isEmpty()) {
            // 通过抛出异常
            throw new RuntimeException("队列空，不能取数据");
        }
        // 这里需要分析出 front是指向队列的第一个元素
        // 1. 先把 front 对应的值保留到一个临时变量
        // 2. 将 front 后移, 考虑取模
        // 3. 将临时保存的变量返回
        int value = arr[front];
        front = (front + 1) % maxSize;
        return value;
    }

    // 显示队列的所有数据
    public void showQueue() {
        // 遍历
        if (isEmpty()) {
            System.out.println("队列空的，没有数据~~");
            return;
        }
        // 思路：从front开始遍历，遍历多少个元素
        // 动脑筋
        for (int i = front; i < front + size() ; i++) {
            System.out.printf("arr[%d]=%d\n", i % maxSize, arr[i % maxSize]);
        }
    }

    public int size() {
        return (rear + maxSize - front) % maxSize;
    }

    // 显示队列的头数据， 注意不是取出数据
    public int headQueue() {
        // 判断
        if (isEmpty()) {
            throw new RuntimeException("队列空的，没有数据~~");
        }
        return arr[front];
    }
}
```

# 3、链表

## 3.1、链表介绍

链表是有序的列表，但是它在内存中是存储如下

![image-20210715222617842](C:\Users\pz\AppData\Roaming\Typora\typora-user-images\image-20210715222617842.png)

1. 链表是以节点的方式来存储,是链式存储
2.  每个节点包含 data 域， next 域：指向下一个节点.
3. 如图：发现链表的各个节点不一定是连续存储
4. 链表分带头节点的链表和没有头节点的链表，根据实际的需求来确定

单链表(带头结点) 逻辑结构示意图如下

![image-20210715222703913](C:\Users\pz\AppData\Roaming\Typora\typora-user-images\image-20210715222703913.png)



## 3.2、单链表的应用实例

使用带 head 头的单向链表实现 –水浒英雄排行榜管理完成对英雄人物的增删改查操作

1. 第一种方法在添加英雄时，直接添加到链表的尾部

![image-20210715222854439](C:\Users\pz\AppData\Roaming\Typora\typora-user-images\image-20210715222854439.png)

2. 第二种方式在添加英雄时，根据排名将英雄插入到指定位置(如果有这个排名，则添加失败，并给出提示)

![image-20210715222935110](C:\Users\pz\AppData\Roaming\Typora\typora-user-images\image-20210715222935110.png)

3. 修改节点功能
   1. 先找到该节点，通过遍历
   2. temp.name = newHeroNode.name ;
   3.  temp.nickname= newHero

4. 删除节点

![image-20210715223028074](C:\Users\pz\AppData\Roaming\Typora\typora-user-images\image-20210715223028074.png)

### 代码实现

```java
package com.lyb.linkedlist;

/**
 * Created with IntelliJ IDEA.
 * User: pz
 * Date: 2021/7/12
 * Time: 22:45
 * Description: No Description
 */
public class SingleLinkedListDemo {
    public static void main(String[] args) {
        //进行测试
        //先创建节点
        HeroNode hero1 = new HeroNode(1, "宋江", "及时雨");
        HeroNode hero2 = new HeroNode(2, "卢俊义", "玉麒麟");
        HeroNode hero3 = new HeroNode(3, "吴用", "智多星");
        HeroNode hero4 = new HeroNode(4, "林冲", "豹子头");
        HeroNode hero5 = new HeroNode(4, "林冲s", "豹子头s");

        SingleLinkedList list = new SingleLinkedList();


//        list.add(hero1);
//        list.add(hero2);
//        list.add(hero3);
//        list.add(hero4);

        list.addByOrder(hero4);
        list.addByOrder(hero2);
        list.addByOrder(hero1);
        list.addByOrder(hero3);

//        list.update(hero5);

        list.delete(1);
//        list.delete(2);
//        list.delete(3);
//        list.delete(4);

        list.show();
    }
}

class SingleLinkedList {
    private HeroNode head = new HeroNode(0, "", "");

    public void add(HeroNode heroNode) {
        //因为head节点不能动，因此我们需要一个辅助指针temp
        HeroNode temp = head;
        //遍历链表，找到最后
        while (true) {
            //找到链表最后
            if (temp.next == null) {
                break;
            }
            //如果没有找到，将temp后移
            temp = temp.next;
        }
        //当退出while循环时，temp就指向链表最后
        //将最后这个节点next指向新的节点
        temp.next = heroNode;
    }

    //第二种方式在添加英雄时，根据排名将英雄插入到指定位置
    //(如果有这个排名，则添加失败，并给出提示)
    public void addByOrder(HeroNode heroNode) {
        //因为头节点不能动，因此我们仍然通过一个辅助指针(变量)来帮助找到添加的位置
        //因为单链表，因为我们找的temp 是位于 添加位置的前一个节点，否则插入不了
        HeroNode temp = head;
        boolean flag = false;// flag标志添加的编号是否存在，默认为false
        while (true) {
            //说明temp已经在链表的最后
            if (temp.next == null) {
                break;
            }
            //说明希望添加的heroNode的编号已然存在
            if (temp.next.no == heroNode.no) {
                flag = true;//说明编号存在
                break;
            }
            //位置找到，就在temp的后面插入
            if (temp.next.no > heroNode.no) {
                break;
            }
            temp = temp.next;//后移，遍历当前链表
        }

        if (flag) {
            System.out.println("准备插入的英雄的编号" + heroNode.no + "已经存在了, 不能加入");
        } else {
            heroNode.next = temp.next;
            temp.next = heroNode;
        }
    }

    //修改节点的信息, 根据no编号来修改，即no编号不能改.
    //说明
    //1. 根据 newHeroNode 的 no 来修改即可
    public void update(HeroNode newHeroNode) {
        //判断是否空
        if (head.next == null) {
            System.out.println("链表为空");
            return;
        }
        //找到需要修改的节点, 根据no编号
        //定义一个辅助变量
        HeroNode temp = head.next;
        boolean flag = false;//表示是否找到该节点
        while (true) {
            if (temp == null) {
                break;
            }
            if (temp.no == newHeroNode.no) {
                flag = true;
                break;
            }
            temp = temp.next;
        }

        if (flag) {
            temp.name = newHeroNode.name;
            temp.nickName = newHeroNode.nickName;
        } else {
            System.out.println("没有找到编号"+ newHeroNode.no +"的节点，不能修改");

        }
    }
    //删除节点
    //思路
    //1. head 不能动，因此我们需要一个temp辅助节点找到待删除节点的前一个节点
    //2. 说明我们在比较时，是temp.next.no 和  需要删除的节点的no比较
    public void delete(int no){
        HeroNode temp = head;
        boolean flag = false;//标识是否找到待删除的节点
        while (true){
            ////已经到链表的最后
            if (temp.next == null){
                System.out.println("链表为空");
                break;
            }
            if (temp.next.no == no){
                //找到的待删除节点的前一个节点temp
                flag = true;
                break;
            }
            temp = temp.next;
        }
        //判断flag
        if (flag){
            temp.next = temp.next.next;
        }else {
            System.out.println("要删除的节点不存在");
        }
    }

    public void show() {
        //判断链表是否为空
        if (head.next == null) {
            System.out.println("链表为空");
            return;
        }
        //因为头节点不能动，因此我们需要一个辅助指针temp
        HeroNode temp = head.next;
        while (true) {
            //判断是否链表为空
            if (temp == null) {
                break;
            }
            System.out.println(temp);
            temp = temp.next;
        }

    }
}


class HeroNode {
    public int no;
    public String name;
    public String nickName;
    public HeroNode next;//指向下一个节点

    //构造器
    public HeroNode(int no, String name, String nickName) {
        this.no = no;
        this.name = name;
        this.nickName = nickName;
    }
    //为了显示方法，我们重新toString

    @Override
    public String toString() {
        return "HeroNode{" +
                "no=" + no +
                ", name='" + name + '\'' +
                ", nickName='" + nickName + '\'' +
                '}';
    }
}

```



## 3.3、双向链表应用实例

