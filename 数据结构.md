# 1、数据结构和算法概述

## 1.1、数据结构和算法的关系

1.  数据 data 结构(structure)是一门研究组织数据方式的学科，有了编程语言也就有了数据结构.学好数据结构可以 编写出更加漂亮,更加有效率的代码。
2. 要学习好数据结构就要多多考虑如何将生活中遇到的问题,用程序去实现解决。
3.  程序 = 数据结构 + 算法
4. 数据结构是算法的基础, 换言之，想要学好算法，需要把数据结构学到位。

1.2、线性结构和非线性结构

数据结构包括：线性结构和非线性结构

### 1.2.1、线性结构

1. 线性结构作为最常用的数据结构，其特点是**数据元素之间存在一对一的线性关系** 
2. 线性结构有两种不同的存储结构，即**顺序存储结构(数组)和链式存储结构(链表)**。顺序存储的线性表称为顺序 表，**顺序表中的存储元素是连续的**
3.  链式存储的线性表称为链表，链表中的**存储元素不一定是连续的**，元素节点中存放数据元素以及相邻元素的地址信息 
4. 线性结构常见的有：**数组、队列、链表和栈**，后面我们会详细讲解.

### 1.2.2、非线性结构

非线性结构包括：二维数组、多维数组、广义表、**树结构、图结构**

# 2、稀疏数组和队列

## 2.1、稀疏数组

### 2.1.1、先看一个实际需求

编写五子棋程序中，有存盘和续上盘的功能

![image-20210710220217327](C:\Users\pz\AppData\Roaming\Typora\typora-user-images\image-20210710220217327.png)



分析问题

因为该二维数组的很多值是默认值0，因此记录了很多没有意义的数据

### 2.1.2、基本介绍

当一个数组中大部分元素为０，或者为同一个值的数组时，可以使用稀疏数组来保存该数组。    



稀疏数组的处理方法是:

1. 记录数组一共有几行几列，有多少个不同的值
2. 把具有不同值的元素的行列及值记录在一个小规模的数组中，从而缩小程序的规模

![image-20210710220446916](C:\Users\pz\AppData\Roaming\Typora\typora-user-images\image-20210710220446916.png)



### 2.1.3、应用实例

1. 使用稀疏数组，来保留类似前面的二维数组(棋盘、地图等等)
2. 把稀疏数组存盘，并且可以从新恢复原来的二维数组数
3. 整体思路分析



![image-20210710220615796](C:\Users\pz\AppData\Roaming\Typora\typora-user-images\image-20210710220615796.png)



```
1. 遍历原始的二维数组，得到有效数据的个数sum
2. 根据sum就可以创建稀疏数组sparseArr int[sum+1][3]
3. 将二维数组的有效数据存入到稀疏数组

稀疏数组转原始的二维数组的思路

1. 先读取稀疏数组的第一行，根据第一行的数据，创建原始的二维数组，比如上面的chessArr=int[11][11]
2. 在读取稀疏数组后几行的数据，并赋给原始的二维数组即可
```

4. 代码实现

```java
public class SparseArray {
    public static void main(String[] args) {
        //先创建一个原始的二维数组 11*11
        //0:表示没有棋子，1：表示黑子，2：表示白子
        int row = 11;
        int column = 11;
        int[][] chessArr1 = new int[row][column];
        chessArr1[1][2] = 1;
        chessArr1[2][3] = 2;
        chessArr1[3][4] = 2;

        //输出原始的二维数组
        System.out.println("输出原始的二维数组");
        for (int[] rows : chessArr1) {
            for (int data : rows) {
                System.out.print(data + "\t");
            }
            System.out.println();
        }
        //将二维数组转换为稀疏数组
        //先遍历二维数组，得到非0数据的个数
        int sum = 0;
        for (int[] rows : chessArr1) {
            for (int data : rows) {
                if (data != 0)
                    sum++;
            }
        }
        System.out.println("sum:" + sum);
        //创建对应的稀疏数组
        int[][] sparseArr = new int[sum + 1][3];
        //给稀疏数组赋值
        sparseArr[0][0] = 11;
        sparseArr[0][1] = 11;
        sparseArr[0][2] = sum;
        //遍历二维数组，将非0的值存放到sparseArr中
        int count = 0;//count用于记录是第几个非0的数据
        for (int i = 0; i < row; i++) {
            for (int j = 0; j < column; j++) {
                if (chessArr1[i][j] != 0) {
                    count++;
                    sparseArr[count][0] = i;
                    ;
                    sparseArr[count][1] = j;
                    ;
                    sparseArr[count][2] = chessArr1[i][j];
                }
            }
        }
        //输出稀疏数组的形式
        System.out.println();
        System.out.println("得到稀疏数组为~~~~");
        for (int i = 0; i < sparseArr.length; i++) {
            System.out.printf("%d\t%d\t%d\t\n", sparseArr[i][0], sparseArr[i][1], sparseArr[i][2]);
        }

        //将稀疏数组恢复成二维数组
        //1. 先读取稀疏数组的第一行，根据第一行的数据，创建原始的二维数组，比如上面的chessArr=int[11][11]
        //2. 在读取稀疏数组后几行的数据，并赋给原始的二维数组即可
        System.out.println();
        //先读取稀疏数组的第一行，根据第一行的数据，创建原始的二维数组
        int[][] chessArr2 = new int[sparseArr[0][0]][sparseArr[0][1]];
        //在读取稀疏数组后几行的数据，并赋给原始的二维数组即可
        for (int i=1;i<sparseArr.length;i++){
            for (int j=0;j<3;j++){
                chessArr2[sparseArr[i][0]][sparseArr[i][1]]=sparseArr[i][2];
            }
        }
        // 输出恢复后的二维数组
        System.out.println();
        System.out.println("输出恢复后的二维数组");
        for (int i = 0; i < row; i++) {
            for (int j = 0; j < column; j++) {
                System.out.print(chessArr2[i][j] + "\t");
            }
            System.out.println();
        }
    }
}
```

## 2.3、队列

### 2.3.1、队列介绍

1. 队列是一个**有序列表**，可以用数组或是**链表**来实现。
2. 遵循**先入先出**的原则。即：**先存入队列的数据，要先取出。后存入的要后取出**
3. 示意图：(使用数组模拟队列示意图)

![image-20210711161915191](C:\Users\pz\AppData\Roaming\Typora\typora-user-images\image-20210711161915191.png)



### 2.3.2、数组模拟队列思路

- 队列本身是有序列表，若使用数组的结构来存储队列的数据，则队列数组的声明如下图, 其中 maxSize 是该队 列的最大容量。
- 因为队列的输出、输入是分别从前后端来处理，因此需要两个变量 front 及 rear 分别记录队列前后端的下标， front 会随着数据输出而改变，而 rear 则是随着数据输入而改变，如图所示

![image-20210711161915191](C:\Users\pz\AppData\Roaming\Typora\typora-user-images\image-20210711161915191.png)

- 当我们将数据存入队列时称为”addQueue”，addQueue 的处理需要有两个步骤：思路分析
  1. 将尾指针往后移：rear+1 , 当 front == rear 【空】
  2. 若尾指针 rear 小于队列的最大下标 maxSize-1，则将数据存入 rear 所指的数组元素中，否则无法存入数据。 rear == maxSize【队列满】

#### 代码实现

```java
//用数组模拟队列，编写一个ArrayQueue
class ArrayQueue{
    private int maxSize;//表示数组的最大容量
    private int front;//队列头
    private int rear;//队列尾
    private int[] arr;//该数组用于存放数据,模拟队列
    // 创建队列的构造器
    public ArrayQueue(int maxSize) {
        this.maxSize = maxSize;
        this.arr = new int[maxSize];
        this.front = -1;//指向队列头部，分析出 front 是指向队列头的前一个位置
        this.rear = -1;//指向队列尾，指向队列尾的数据(即就是队列最后一个数据)
    }
    //判断队列是否满
    public boolean isFull(){
        return rear == maxSize-1;
    }
    //判断队列是否为空
    public boolean isEmpty(){
        return rear == front;
    }
    //添加数据到队列
    public void addQueue(int n){
        // 判断队列是否满
        if(isFull()){
            System.out.println("队列满，不能加入数据~");
            return;
        }
        rear++;
        arr[rear] = n;
    }
    //获取队列的数据，出队列
    public int getQueue(){
        //判断队列是否为空
        if (isEmpty()){
            throw new RuntimeException("队列空，不能取数据");
        }
        front++;
        return arr[front];
    }
    //显示队列的所以数据
    public void showQueue(){
        //判断队列是否为空
        if (isEmpty()){
            System.out.println("队列空的，没有数据~~");
            return;
        }
        for (int i = 0; i < arr.length; i++) {
            System.out.println("arr["+i+"]="+arr[i]);
        }
    }
    //显示队列的头数据，注意不是取出数据
    public int headQueue(){
        //判断队列是否为空
        if (isEmpty()){
            throw new RuntimeException("队列空的，没有数据~~");
        }
        return arr[front + 1];
    }
}
```

#### 测试代码

```java
public static void main(String[] args) {
        //测试一把
        //创建一个队列
        ArrayQueue queue = new ArrayQueue(3);
        char key = ' '; //接收用户输入
        Scanner scanner = new Scanner(System.in);//
        boolean loop = true;
        //输出一个菜单
        while(loop) {
            System.out.println("s(show): 显示队列");
            System.out.println("e(exit): 退出程序");
            System.out.println("a(add): 添加数据到队列");
            System.out.println("g(get): 从队列取出数据");
            System.out.println("h(head): 查看队列头的数据");
            key = scanner.next().charAt(0);//接收一个字符
            switch (key) {
                case 's':
                    queue.showQueue();
                    break;
                case 'a':
                    System.out.println("输出一个数");
                    int value = scanner.nextInt();
                    queue.addQueue(value);
                    break;
                case 'g': //取出数据
                    try {
                        int res = queue.getQueue();
                        System.out.printf("取出的数据是%d\n", res);
                    } catch (Exception e) {
                        // TODO: handle exception
                        System.out.println(e.getMessage());
                    }
                    break;
                case 'h': //查看队列头的数据
                    try {
                        int res = queue.headQueue();
                        System.out.printf("队列头的数据是%d\n", res);
                    } catch (Exception e) {
                        // TODO: handle exception
                        System.out.println(e.getMessage());
                    }
                    break;
                case 'e': //退出
                    scanner.close();
                    loop = false;
                    break;
                default:
                    break;
            }
        }
        System.out.println("程序退出~~");
    }
```

### 2.3.3、数组模拟环形队列

对前面的数组模拟队列的优化，充分利用数组. 因此将数组看做是一个环形的。(**通过取模的方式来实现即可**)

#### 分析说明

1. 尾索引的下一个为头索引时表示队列满，即将队列容量空出一个作为约定,这个在做判断队列满的 时候需要注意 (rear + 1) % maxSize == front 满
2. rear == front
3.  分析示意图

![image-20210715222359902](C:\Users\pz\AppData\Roaming\Typora\typora-user-images\image-20210715222359902.png)

#### 代码实现

```java
class CircleArray {
    private int maxSize; // 表示数组的最大容量
    /*
    front 变量的含义做一个调整： front 就指向队列的第一个元素, 也就是说 arr[front] 就是队列的第一个元素
    front 的初始值 = 0
    */
    private int front;
    /*
    rear 变量的含义做一个调整：rear 指向队列的最后一个元素的后一个位置. 因为希望空出一个空间做为约定.
    rear 的初始值 = 0
    */
    private int rear; // 队列尾
    private int[] arr; // 该数据用于存放数据, 模拟队列

    public CircleArray(int arrMaxSize) {
        maxSize = arrMaxSize;
        arr = new int[maxSize];
        front = 0;
        rear = 0;
    }
    // 判断队列是否满
    public boolean isFull() {
        return (rear  + 1) % maxSize == front;
    }

    // 判断队列是否为空
    public boolean isEmpty() {
        return rear == front;
    }

    // 添加数据到队列
    public void addQueue(int n) {
        // 判断队列是否满
        if (isFull()) {
            System.out.println("队列满，不能加入数据~");
            return;
        }
        //直接将数据加入
        arr[rear] = n;
        //将 rear 后移, 这里必须考虑取模
        rear = (rear + 1) % maxSize;
    }

    // 获取队列的数据, 出队列
    public int getQueue() {
        // 判断队列是否空
        if (isEmpty()) {
            // 通过抛出异常
            throw new RuntimeException("队列空，不能取数据");
        }
        // 这里需要分析出 front是指向队列的第一个元素
        // 1. 先把 front 对应的值保留到一个临时变量
        // 2. 将 front 后移, 考虑取模
        // 3. 将临时保存的变量返回
        int value = arr[front];
        front = (front + 1) % maxSize;
        return value;
    }

    // 显示队列的所有数据
    public void showQueue() {
        // 遍历
        if (isEmpty()) {
            System.out.println("队列空的，没有数据~~");
            return;
        }
        // 思路：从front开始遍历，遍历多少个元素
        // 动脑筋
        for (int i = front; i < front + size() ; i++) {
            System.out.printf("arr[%d]=%d\n", i % maxSize, arr[i % maxSize]);
        }
    }

    public int size() {
        return (rear + maxSize - front) % maxSize;
    }

    // 显示队列的头数据， 注意不是取出数据
    public int headQueue() {
        // 判断
        if (isEmpty()) {
            throw new RuntimeException("队列空的，没有数据~~");
        }
        return arr[front];
    }
}
```

# 3、链表

## 3.1、链表介绍

链表是有序的列表，但是它在内存中是存储如下

![image-20210715222617842](C:\Users\pz\AppData\Roaming\Typora\typora-user-images\image-20210715222617842.png)

1. 链表是以节点的方式来存储,是链式存储
2.  每个节点包含 data 域， next 域：指向下一个节点.
3. 如图：发现链表的各个节点不一定是连续存储
4. 链表分带头节点的链表和没有头节点的链表，根据实际的需求来确定

单链表(带头结点) 逻辑结构示意图如下

![image-20210715222703913](C:\Users\pz\AppData\Roaming\Typora\typora-user-images\image-20210715222703913.png)



## 3.2、单链表的应用实例

使用带 head 头的单向链表实现 –水浒英雄排行榜管理完成对英雄人物的增删改查操作

1. 第一种方法在添加英雄时，直接添加到链表的尾部

![image-20210715222854439](C:\Users\pz\AppData\Roaming\Typora\typora-user-images\image-20210715222854439.png)

2. 第二种方式在添加英雄时，根据排名将英雄插入到指定位置(如果有这个排名，则添加失败，并给出提示)

![image-20210715222935110](C:\Users\pz\AppData\Roaming\Typora\typora-user-images\image-20210715222935110.png)

3. 修改节点功能
   1. 先找到该节点，通过遍历
   2. temp.name = newHeroNode.name ;
   3.  temp.nickname= newHero

4. 删除节点

![image-20210715223028074](C:\Users\pz\AppData\Roaming\Typora\typora-user-images\image-20210715223028074.png)

### 代码实现

```java
package com.lyb.linkedlist;

/**
 * Created with IntelliJ IDEA.
 * User: pz
 * Date: 2021/7/12
 * Time: 22:45
 * Description: No Description
 */
public class SingleLinkedListDemo {
    public static void main(String[] args) {
        //进行测试
        //先创建节点
        HeroNode hero1 = new HeroNode(1, "宋江", "及时雨");
        HeroNode hero2 = new HeroNode(2, "卢俊义", "玉麒麟");
        HeroNode hero3 = new HeroNode(3, "吴用", "智多星");
        HeroNode hero4 = new HeroNode(4, "林冲", "豹子头");
        HeroNode hero5 = new HeroNode(4, "林冲s", "豹子头s");

        SingleLinkedList list = new SingleLinkedList();


//        list.add(hero1);
//        list.add(hero2);
//        list.add(hero3);
//        list.add(hero4);

        list.addByOrder(hero4);
        list.addByOrder(hero2);
        list.addByOrder(hero1);
        list.addByOrder(hero3);

//        list.update(hero5);

        list.delete(1);
//        list.delete(2);
//        list.delete(3);
//        list.delete(4);

        list.show();
    }
}

class SingleLinkedList {
    private HeroNode head = new HeroNode(0, "", "");

    public void add(HeroNode heroNode) {
        //因为head节点不能动，因此我们需要一个辅助指针temp
        HeroNode temp = head;
        //遍历链表，找到最后
        while (true) {
            //找到链表最后
            if (temp.next == null) {
                break;
            }
            //如果没有找到，将temp后移
            temp = temp.next;
        }
        //当退出while循环时，temp就指向链表最后
        //将最后这个节点next指向新的节点
        temp.next = heroNode;
    }

    //第二种方式在添加英雄时，根据排名将英雄插入到指定位置
    //(如果有这个排名，则添加失败，并给出提示)
    public void addByOrder(HeroNode heroNode) {
        //因为头节点不能动，因此我们仍然通过一个辅助指针(变量)来帮助找到添加的位置
        //因为单链表，因为我们找的temp 是位于 添加位置的前一个节点，否则插入不了
        HeroNode temp = head;
        boolean flag = false;// flag标志添加的编号是否存在，默认为false
        while (true) {
            //说明temp已经在链表的最后
            if (temp.next == null) {
                break;
            }
            //说明希望添加的heroNode的编号已然存在
            if (temp.next.no == heroNode.no) {
                flag = true;//说明编号存在
                break;
            }
            //位置找到，就在temp的后面插入
            if (temp.next.no > heroNode.no) {
                break;
            }
            temp = temp.next;//后移，遍历当前链表
        }

        if (flag) {
            System.out.println("准备插入的英雄的编号" + heroNode.no + "已经存在了, 不能加入");
        } else {
            heroNode.next = temp.next;
            temp.next = heroNode;
        }
    }

    //修改节点的信息, 根据no编号来修改，即no编号不能改.
    //说明
    //1. 根据 newHeroNode 的 no 来修改即可
    public void update(HeroNode newHeroNode) {
        //判断是否空
        if (head.next == null) {
            System.out.println("链表为空");
            return;
        }
        //找到需要修改的节点, 根据no编号
        //定义一个辅助变量
        HeroNode temp = head.next;
        boolean flag = false;//表示是否找到该节点
        while (true) {
            if (temp == null) {
                break;
            }
            if (temp.no == newHeroNode.no) {
                flag = true;
                break;
            }
            temp = temp.next;
        }

        if (flag) {
            temp.name = newHeroNode.name;
            temp.nickName = newHeroNode.nickName;
        } else {
            System.out.println("没有找到编号"+ newHeroNode.no +"的节点，不能修改");

        }
    }
    //删除节点
    //思路
    //1. head 不能动，因此我们需要一个temp辅助节点找到待删除节点的前一个节点
    //2. 说明我们在比较时，是temp.next.no 和  需要删除的节点的no比较
    public void delete(int no){
        HeroNode temp = head;
        boolean flag = false;//标识是否找到待删除的节点
        while (true){
            ////已经到链表的最后
            if (temp.next == null){
                System.out.println("链表为空");
                break;
            }
            if (temp.next.no == no){
                //找到的待删除节点的前一个节点temp
                flag = true;
                break;
            }
            temp = temp.next;
        }
        //判断flag
        if (flag){
            temp.next = temp.next.next;
        }else {
            System.out.println("要删除的节点不存在");
        }
    }

    public void show() {
        //判断链表是否为空
        if (head.next == null) {
            System.out.println("链表为空");
            return;
        }
        //因为头节点不能动，因此我们需要一个辅助指针temp
        HeroNode temp = head.next;
        while (true) {
            //判断是否链表为空
            if (temp == null) {
                break;
            }
            System.out.println(temp);
            temp = temp.next;
        }

    }
}


class HeroNode {
    public int no;
    public String name;
    public String nickName;
    public HeroNode next;//指向下一个节点

    //构造器
    public HeroNode(int no, String name, String nickName) {
        this.no = no;
        this.name = name;
        this.nickName = nickName;
    }
    //为了显示方法，我们重新toString

    @Override
    public String toString() {
        return "HeroNode{" +
                "no=" + no +
                ", name='" + name + '\'' +
                ", nickName='" + nickName + '\'' +
                '}';
    }
}

```



## 3.3、双向链表应用实例

### 3.3.1、 Josephu 问题

Josephu 问题为：设编号为 1，2，… n 的 n 个人围坐一圈，约定编号为 k（1<=k<=n）的人从 1 开始报数，数到 m 的那个人出列，它的下一位又从 1 开始报数，数到 m 的那个人又出列，依次类推，直到所有人出列为止，由此 产生一个出队编号的序列。

![image-20210726231446116](C:\Users\pz\AppData\Roaming\Typora\typora-user-images\image-20210726231446116.png)

#### 约瑟夫问题-创建环形链表的思路图解

![image-20210726231628497](C:\Users\pz\AppData\Roaming\Typora\typora-user-images\image-20210726231628497.png)

构建一个单向的环形链表思路

1. 先创建第一个节点，让first指向该节点，并形成环形
2. 后面当我们每创建一个新的节点，就把该节点，加入到已有的环形链表中即可

遍历环形链表

1. 先让一个辅助指针curBoy，指向firts节点
2. 然后通过一个while循环遍历该环形链表即可 curBoy.next == first 结束

#### 约瑟夫问题-小孩出圈的思路分析图解

![image-20210726232008151](C:\Users\pz\AppData\Roaming\Typora\typora-user-images\image-20210726232008151.png)

根据用户的输入，先生成一个小孩的出圈顺序

n=5 即有5个人

k=1 从第一个人开始报数

m=2 数2下



1. 需求创建一个辅助指针(变量) helper , 事先应该指向环形链表的最后这个节点.

   补充： 小孩报数前，先让 first 和 helper 移动 k - 1次

2. 当小孩报数时，让first 和 helper 指针同时 的移动 m - 1 次

3. 这时就可以将first 指向的小孩节点 出圈

   	first = first .next 
   	
   	helper.next = first 

原来first 指向的节点就没有任何引用，就会被回收

### 3.3.2、Josephu 问题的代码实现

```java
package com.lyb.linkedlist;
public class Josephu {
    public static void main(String[] args) {
        CircleSingleLinkedList circleSingleLinkedList = new CircleSingleLinkedList();
        circleSingleLinkedList.addBoy(5);
        circleSingleLinkedList.showBoy();
        circleSingleLinkedList.countBoy(1, 2, 5); // 2->4->1->5->3
    }
}

//创建一个环形的单向链表
class CircleSingleLinkedList {
    //创建一个first节点，当前没有编号
    private Boy first = new Boy(-1);

    //添加小孩节点，构建一个环形的链表
    public void addBoy(int nums) {
        if (nums < 1) {
            System.out.println("nums的值不正确");
            return;
        }
        Boy curBoy = null;//赋值指针，帮助构建环形链表
        //使用for来创建我们的环形链表
        for (int i = 1; i <= nums; i++) {
            //根据编号,来创建小孩节点
            Boy boy = new Boy(i);
            if (i == 1) {
                first = boy;
                first.setNext(first);
                curBoy = first;
            } else {
                curBoy.setNext(boy);
                boy.setNext(first);
                curBoy = boy;
            }
        }
    }

    //遍历当前的环形链表
    public void showBoy() {
        //判断链表是否为空
        if (first == null) {
            System.out.println("没有任何小孩");
            return;
        }
        //因为first不能动，因此我们仍然使用一个辅助指针完成遍历
        Boy curBoy = first;
        while (true){
            System.out.println("小孩的编号"+curBoy.getNo());
            if(curBoy.getNext() == first){//说明遍历完毕了
                break;
            }
            curBoy = curBoy.getNext();
        }
    }


    //根据用户的输入，计算出小孩出圈的顺序、
    /**
     *
     * @param startNo
     *            表示从第几个小孩开始数数
     * @param countNum
     *            表示数几下
     * @param nums
     *            表示最初有多少小孩在圈中
     */
    public void countBoy(int startNo,int countNum,int nums){
        //先对数据进行校验
        if (first == null || startNo < 1 || startNo > nums){
            System.out.println("参数输入有误，请重新输入");
            return;
        }

        // 创建要给辅助指针,帮助完成小孩出圈
        Boy helper = first;
        while (true) {
            if (helper.getNext() == first) { // 说明helper指向最后小孩节点
                break;
            }
            helper = helper.getNext();
        }
        //小孩报数前，先让 first 和  helper 移动 k - 1次
        for(int j = 0; j < startNo - 1; j++) {
            first = first.getNext();
            helper = helper.getNext();
        }

        //当小孩报数时，让first 和 helper 指针同时 的移动  m  - 1 次, 然后出圈
        //这里是一个循环操作，知道圈中只有一个节点
        while (true){
            if (helper == first){//说明圈中只有一个节点
                break;
            }
            //让 first 和 helper 指针同时 的移动 countNum - 1
            for (int j = 0;j<countNum-1; j++){
                first = first.getNext();
                helper = helper.getNext();
            }
            //这时first指向的节点，就是要出圈的小孩节点
            System.out.println("小孩"+first.getNo()+"出圈");
            //这时将first指向的小孩节点出圈
            first = first.getNext();
            helper.setNext(first);
        }
        System.out.println("最后留在圈中的小孩编号"+first.getNo());
    }
}


class Boy {
    private int no;//编号
    private Boy next;//指向下一个节点，默认null

    public Boy(int no) {
        this.no = no;
    }

    public int getNo() {
        return no;
    }

    public void setNo(int no) {
        this.no = no;
    }

    public Boy getNext() {
        return next;
    }

    public void setNext(Boy next) {
        this.next = next;
    }

    @Override
    public String toString() {
        return "Boy{" +
                "no=" + no +
                ", next=" + next +
                '}';
    }
}
```

# 4、栈

## 4.1、栈的一个实际需求

请输入一个表达式 

计算式:[7*2*2-5+1-5+3-3] 点击计算【如下图】

![image-20210727220401963](C:\Users\pz\AppData\Roaming\Typora\typora-user-images\image-20210727220401963.png)

## 4.2、栈的介绍

1. 栈的英文（stack）
2. 栈是一个先入后出的有序列表
3. 栈（stack）是限制线性表中元素的插入和删除只能在线性表的同一端进行的一种特殊线性表。允许插入和删除一端，为变化的一端，称为栈顶（Top），另一端为固定的一端，称为栈底（Button）.
4.  根据栈的定义可知，最先放入栈中元素在栈底，最后放入的元素在栈顶，而删除元素刚好相反，最后放入的元 素最先删除，最先放入的元素最后删除
5.  图解方式说明出栈(pop)和入栈(push)的概念

![image-20210727221344868](C:\Users\pz\AppData\Roaming\Typora\typora-user-images\image-20210727221344868.png)

![image-20210727221348979](C:\Users\pz\AppData\Roaming\Typora\typora-user-images\image-20210727221348979.png)

## 4.3 栈的应用场景

1. 子程序的调用：在跳往子程序前，会先将下个指令的地址存到堆栈中，直到子程序执行完后再将地址取出，以
   回到原来的程序中。
2.  处理递归调用：和子程序的调用类似，只是除了储存下一个指令的地址外，也将参数、区域变量等数据存入堆栈中。
3.  表达式的转换[中缀表达式转后缀表达式]与求值(实际解决)。
4. 二叉树的遍历。
5.  图形的深度优先(depth 一 first)搜索法。

## 4.4 栈的快速入门

1. 用数组模拟栈的使用，由于栈是一种有序列表，当然可以使用数组的结构来储存栈的数据内容， 下面我们就用数组模拟栈的出栈，入栈等操作。
2.  实现思路分析,并画出示意图

![image-20210727221556722](C:\Users\pz\AppData\Roaming\Typora\typora-user-images\image-20210727221556722.png)

### 代码实现

```java
package com.lyb.stack;

import java.util.Scanner;

/**
 * Created with IntelliJ IDEA.
 * User: pz
 * Date: 2021/7/27
 * Time: 21:42
 * Description: No Description
 */
public class ArrayStackDemo {
    public static void main(String[] args) {
        //测试一下ArrayStack 是否正确
        //先创建一个ArrayStack对象->表示栈
        ArrayStack stack = new ArrayStack(4);
        String key = "";
        boolean loop = true; //控制是否退出菜单
        Scanner scanner = new Scanner(System.in);

        while(loop) {
            System.out.println("show: 表示显示栈");
            System.out.println("exit: 退出程序");
            System.out.println("push: 表示添加数据到栈(入栈)");
            System.out.println("pop: 表示从栈取出数据(出栈)");
            System.out.println("请输入你的选择");
            key = scanner.next();
            switch (key) {
                case "show":
                    stack.show();
                    break;
                case "push":
                    System.out.println("请输入一个数");
                    int value = scanner.nextInt();
                    stack.push(value);
                    break;
                case "pop":
                    try {
                        int res = stack.pop();
                        System.out.printf("出栈的数据是 %d\n", res);
                    } catch (Exception e) {
                        // TODO: handle exception
                        System.out.println(e.getMessage());
                    }
                    break;
                case "exit":
                    scanner.close();
                    loop = false;
                    break;
                default:
                    break;
            }
        }

        System.out.println("程序退出~~~");
    }
}

class ArrayStack{
    private int maxSize;//栈的大小
    private int[] stack;//数组，数组模拟栈，数据就放在该数组
    private int top = -1;//top表示栈顶，初始化为-1
    //构造器
    public ArrayStack(int maxSize) {
        this.maxSize = maxSize;
        stack = new int[maxSize];
    }

    //栈满
    public boolean isFull(){
        return top == maxSize - 1;
    }
    //栈空
    public boolean isEmpty(){
        return top == -1;
    }
    //入栈-push
    public void push(int value){
        if (isFull()){
            System.out.println("栈满");
            return;
        }
        top++;
        stack[top] = value;
    }
    //出栈-pop, 将栈顶的数据返回
    public int pop(){
        if (isEmpty()){
            throw new RuntimeException("栈空，没有数据");
        }
        int value = stack[top];
        top--;
        return value;
    }
    //显示栈的情况[遍历栈]， 遍历时，需要从栈顶开始显示数据
    public void show(){
        if (isEmpty()){
            System.out.println("栈空，没有数据");
            return;
        }
        for (int i = top; i >= 0 ; i--) {
            System.out.println("stack"+i+"="+stack[i]);
        }
    }
}
```

## 4.5 栈实现综合计算器(中缀表达式)

使用栈来实现综合计算器

### 思路分析

![image-20210801223440639](C:\Users\pz\AppData\Roaming\Typora\typora-user-images\image-20210801223440639.png)

### 代码实现

```java
package com.lyb.stack;

/**
 * Created with IntelliJ IDEA.
 * User: pz
 * Date: 2021/7/28
 * Time: 23:22
 * Description: No Description
 */
public class Calculator {
    public static void main(String[] args) {
        //根据前面老师思路，完成表达式的运算
        String expression = "7*2*2-5+1-5+3-4"; // 15
        //创建两个栈，数栈，一个符号栈
        ArrayStack2 numStack = new ArrayStack2(10);
        ArrayStack2 operStack = new ArrayStack2(10);
        //定义需要的相关变量
        int index = 0;//用于扫描
        int num1 = 0;
        int num2 = 0;
        int oper = 0;
        int res = 0;
        char ch = ' '; //将每次扫描得到char保存到ch
        String keepNum = ""; //用于拼接 多位数
        //开始while循环的扫描expression
        while (true){
            ch = expression.substring(index,index+1).charAt(0);
            if (operStack.isOper(ch)){//如果是运算符
                //判断当前的符号栈是否为空
                if (!operStack.isEmpty()){
                    //如果符号栈有操作符，就进行比较,如果当前的操作符的优先级小于或者等于栈中的操作符,就需要从数栈中pop出两个数,
                    //在从符号栈中pop出一个符号，进行运算，将得到结果，入数栈，然后将当前的操作符入符号栈
                    if (operStack.priority(ch) <= operStack.priority(operStack.peek())){
                        num1 = numStack.pop();
                        num2 = numStack.pop();
                        oper = operStack.pop();
                        res = numStack.cal(num1, num2, oper);
                        //把运算的结果如数栈
                        numStack.push(res);
                        //然后将当前的操作符入符号栈
                        operStack.push(ch);
                    }else{
                        //如果当前的操作符的优先级大于栈中的操作符， 就直接入符号栈.
                        operStack.push(ch);
                    }
                }else {
                    //如果为空直接入符号栈..
                    operStack.push(ch); // 1 + 3
                }
            }else {
                //如果是数，则直接入数栈

                //numStack.push(ch - 48); //? "1+3" '1' => 1
                //分析思路
                //1. 当处理多位数时，不能发现是一个数就立即入栈，因为他可能是多位数
                //2. 在处理数，需要向expression的表达式的index 后再看一位,如果是数就进行扫描，如果是符号才入栈
                //3. 因此我们需要定义一个变量 字符串，用于拼接\

                //处理多位数
                keepNum += ch;
                //如果ch已经是expression的最后一位，就直接入栈
                if (index == expression.length() - 1){
                    numStack.push(Integer.parseInt(keepNum));
                }else {
                    //判断下一个字符是不是数字，如果是数字，就继续扫描，如果是运算符，则入栈
                    //注意是看后一位，不是index++
                    if (operStack.isOper(expression.substring(index+1,index+2).charAt(0))){
                        //如果后一位是运算符，则入栈 keepNum = "1" 或者 "123"
                        numStack.push(Integer.parseInt(keepNum));
                        //重要的!!!!!!, keepNum清空
                        keepNum = "";
                    }
                }
            }
            index++;
            if (index >=expression.length()){
                break;
            }
        }
        //当表达式扫描完毕，就顺序的从 数栈和符号栈中pop出相应的数和符号，并运行.
        while (true){
            //如果符号栈为空，则计算到最后的结果, 数栈中只有一个数字【结果】
            if (operStack.isEmpty()){
                break;
            }
            num1 = numStack.pop();
            num2 = numStack.pop();
            oper = operStack.pop();
            res = numStack.cal(num1, num2, oper);
            numStack.push(res);//入栈
        }
        //将数栈的最后数，pop出，就是结果
        int res2 = numStack.pop();
        System.out.printf("表达式 %s = %d", expression, res2);
    }
}



class ArrayStack2{
    private int maxSize;//栈的大小
    private int[] stack;//数组，数组模拟栈，数据就放在该数组
    private int top = -1;//top表示栈顶，初始化为-1
    //构造器
    public ArrayStack2(int maxSize) {
        this.maxSize = maxSize;
        stack = new int[maxSize];
    }

    //栈满
    public boolean isFull(){
        return top == maxSize - 1;
    }
    //栈空
    public boolean isEmpty(){
        return top == -1;
    }
    //入栈-push
    public void push(int value){
        if (isFull()){
            System.out.println("栈满");
            return;
        }
        top++;
        stack[top] = value;
    }
    //出栈-pop, 将栈顶的数据返回
    public int pop(){
        if (isEmpty()){
            throw new RuntimeException("栈空，没有数据");
        }
        int value = stack[top];
        top--;
        return value;
    }
    //显示栈的情况[遍历栈]， 遍历时，需要从栈顶开始显示数据
    public void show(){
        if (isEmpty()){
            System.out.println("栈空，没有数据");
            return;
        }
        for (int i = top; i >= 0 ; i--) {
            System.out.println("stack"+i+"="+stack[i]);
        }
    }

    //增加一个方法，可以返回当前栈顶的值, 但是不是真正的pop
    public int peek() {
        return stack[top];
    }

    //返回运算符的优先级，优先级是程序员来确定, 优先级使用数字表示
    //数字越大，则优先级就越高.
    public int priority(int oper){
        if (oper == '*' || oper == '/'){
            return 1;
        }else if (oper == '+' || oper == '-')
        {
            return 0;
        }else {
            return -1;
        }
    }

    //判断是不是一个运算符
    public boolean isOper(char val) {
        return val == '+' || val == '-' || val == '*' || val == '/';
    }

    //计算方法
    public int cal(int num1, int num2, int oper) {
        int res = 0; // res 用于存放计算的结果
        switch (oper) {
            case '+':
                res = num1 + num2;
                break;
            case '-':
                res = num2 - num1;// 注意顺序
                break;
            case '*':
                res = num1 * num2;
                break;
            case '/':
                res = num2 / num1;
                break;
            default:
                break;
        }
        return res;
    }
}
```

## 4.6、逆波兰计算器

我们完成一个逆波兰计算器，要求完成如下任务:

1. 输入一个逆波兰表达式（后缀表达式），使用栈，计算器结构
2. 支持小括号和多位数整数，因为这里我们主要讲的是数据结构，因此计算器进行简化，只支持对整数的计算。
3.  思路分析

```md
例如: (3+4)×5-6 对应的后缀表达式就是 3 4 + 5 × 6 - , 针对后缀表达式求值步骤如下:
1．从左至右扫描，将 3 和 4 压入堆栈；
2．遇到+运算符，因此弹出 4 和 3（4 为栈顶元素，3 为次顶元素），计算出 3+4 的值，得 7，再将 7 入栈；
3．将 5 入栈；
4．接下来是×运算符，因此弹出 5 和 7，计算出 7×5=35，将 35 入栈；
5．将 6 入栈；
6．最后是-运算符，计算出 35-6 的值，即 29，由此得出最终结果
```



## 4.7、中缀表达式转换为后缀表达式

大家看到，后缀表达式适合计算式进行运算，但是人却不太容易写出来，尤其是表达式很长的情况下，因此在开发 中，我们需要将 中缀表达式转成后缀表达

### 思路分析

1. 初始化两个栈：运算符栈 s1 和储存中间结果的栈 s2；
2. 从左至右扫描中缀表达式；
3.  遇到操作数时，将其压 s2；
4. 遇到运算符时，比较其与 s1 栈顶运算符的优先级：
   1. 如果 s1 为空，或栈顶运算符为左括号“(”，则直接将此运算符入栈；
   2. 否则，若优先级比栈顶运算符的高，也将运算符压入 s1；
   3. 否则，将 s1 栈顶的运算符弹出并压入到 s2 中，再次转到(4-1)与 s1 中新的栈顶运算符相比较；
5. 遇到括号时：
   1. 如果是左括号“(”，则直接压入 s
   2. 如果是右括号“)”，则依次弹出 s1 栈顶的运算符，并压入 s2，直到遇到左括号为止，此时将这一对括号丢弃
6. 重复步骤 2 至 5，直到表达式的最右
7. 将 s1 中剩余的运算符依次弹出并压入 s2
8.  依次弹出 s2 中的元素并输出，结果的逆序即为中缀表达式对应的后缀表达式

#### 图解

![image-20210801224310460](C:\Users\pz\AppData\Roaming\Typora\typora-user-images\image-20210801224310460.png)

### 代码实现(包含4.6)

```java
package com.lyb.stack;

import java.util.ArrayList;
import java.util.List;
import java.util.Stack;

/**
 * Created with IntelliJ IDEA.
 * User: pz
 * Date: 2021/7/31
 * Time: 21:54
 * Description: No Description
 */
public class PolandNotation {
    public static void main(String[] args) {

        //完成将一个中缀表达式转成后缀表达式的功能
        //说明
        //1. 1+((2+3)×4)-5 => 转成  1 2 3 + 4 × + 5 –
        //2. 因为直接对str 进行操作，不方便，因此 先将  "1+((2+3)×4)-5" =》 中缀的表达式对应的List
        //   即 "1+((2+3)×4)-5" => ArrayList [1,+,(,(,2,+,3,),*,4,),-,5]
        //3. 将得到的中缀表达式对应的List => 后缀表达式对应的List
        //   即 ArrayList [1,+,(,(,2,+,3,),*,4,),-,5]  =》 ArrayList [1,2,3,+,4,*,+,5,–]
        String expression = "1+((2+3)*4)-5";//注意表达式
        List<String> infixExpressionList = toInfixExpressionList(expression);
        System.out.println("中缀表达式对应的List=" + infixExpressionList); // ArrayList [1,+,(,(,2,+,3,),*,4,),-,5]
        List<String> suffixExpreesionList = parseSuffixExpreesionList(infixExpressionList);
        System.out.println("后缀表达式对应的List" + suffixExpreesionList); //ArrayList [1,2,3,+,4,*,+,5,–]

        System.out.printf("expression=%d",calculate(suffixExpreesionList)); // ?


        /**
        //先定义给逆波兰表达式
        //（3+4）*5-6 =》 3 4 + 5 * 6 -
        //逆波兰表达式的数字和符合使用空格隔开
        String suffixExpression="3 4 + 5 * 6 -";
        //思路
        //1、先将"3 4 + 5 * 6 -"放到ArrayList中
        //2、将ArrayList传递给一个方法，遍历ArrayList配合栈完成计算

        List<String> list = getListString(suffixExpression);
        System.out.println("rpnList="+list);
        int res =calulate(list);
        System.out.println("计算结果是"+res);
         */
    }

    public static List<String> getListString(String suffixExpression){
        //将suffixExpression分割
        String[] split = suffixExpression.split(" ");
        List<String> list = new ArrayList<String>();
        for (String ele:split){
            list.add(ele);
        }
        return list;
    }

    //完成对逆波兰表达式的运算
    /*
    1、从左到右扫描将3和4压入栈
    2、遇到+运算符，因此弹出4和3（4为栈顶元素，3为次顶元元素），计算3+4的值，再将计算的值入栈
    3、将5入栈
    4、接下来是*运算符，弹出5和7，计算5*7的值，再将计算的值入栈
    5、将5入栈
    6、最后是-运算符，弹出35和6，计算35-6的值，再将计算的值入栈
     */
    public static int calculate(List<String> list){
        //创建栈
        Stack<String> stack = new Stack<>();
        //遍历
        for (String item: list){
            //使用正则表达式
            if (item.matches("\\d+")){
                //入栈
                stack.push(item);
            }else {
                // pop出两个数，并运算， 再入栈
                int num2 = Integer.parseInt(stack.pop());
                int num1 = Integer.parseInt(stack.pop());
                int res = 0;
                if (item.equals("+")) {
                    res = num1 + num2;
                } else if (item.equals("-")) {
                    res = num1 - num2;
                } else if (item.equals("*")) {
                    res = num1 * num2;
                } else if (item.equals("/")) {
                    res = num1 / num2;
                } else {
                    throw new RuntimeException("运算符有误");
                }
                //把res入栈
                stack.push(String.valueOf(res));
            }
        }
        //最后留在stack中的数据是运算结果
        return Integer.parseInt(stack.pop());
    }

    //方法：将中缀表达式转成对应的List
    //  s="1+((2+3)×4)-5";
    public static List<String> toInfixExpressionList(String s){
        //定义一个List,存放中缀表达式 对应的内容
        List<String> list =new ArrayList<String>();
        int i=0;
        String str;
        char c;
        do {
            //如果c是一个非数字，我需要加入到ls
            if((c=s.charAt(i)) < 48 ||  (c=s.charAt(i)) > 57) {
                list.add("" + c);
                i++; //i需要后移
            } else { //如果是一个数，需要考虑多位数
                str = ""; //先将str 置成"" '0'[48]->'9'[57]
                while(i < s.length() && (c=s.charAt(i)) >= 48 && (c=s.charAt(i)) <= 57) {
                    str += c;//拼接
                    i++;
                }
                list.add(str);
            }
        }while (i < s.length());
        return list;
    }

    //即 ArrayList [1,+,(,(,2,+,3,),*,4,),-,5]  =》 ArrayList [1,2,3,+,4,*,+,5,–]
    //方法：将得到的中缀表达式对应的List => 后缀表达式对应的List
    public static List<String> parseSuffixExpreesionList(List<String> list){
        //定义两个栈
        Stack<String> s1 = new Stack<String>(); // 符号栈
        //说明：因为s2 这个栈，在整个转换过程中，没有pop操作，而且后面我们还需要逆序输出
        //因此比较麻烦，这里我们就不用 Stack<String> 直接使用 List<String> s2
        List<String> s2 = new ArrayList<String>(); // 储存中间结果的Lists2
        //遍历list
        for (String item:list){
            //如果是一个数，加入s2
            if (item.matches("\\d+")){
                s2.add(item);
            }else if (item.equals("(")){
                s1.push(item);
            }else if (item.equals(")")){
                //如果是右括号“)”，则依次弹出s1栈顶的运算符，并压入s2，直到遇到左括号为止，此时将这一对括号丢弃
                while (!s1.peek().equals("(")){
                    s2.add(s1.pop());
                }
                s1.pop();
            }else {
                //当item的优先级小于等于s1栈顶运算符, 将s1栈顶的运算符弹出并加入到s2中，再次转到(4.1)与s1中新的栈顶运算符相比较
                //问题：我们缺少一个比较优先级高低的方法
                while (s1.size()!=0 && Operation.getValue(s1.peek()) >= Operation.getValue(item)){
                    s2.add(s1.pop());
                }
                s1.push(item);
            }
        }
        //将s1中剩余的运算符依次弹出并加入s2
        while (s1.size()!=0){
            s2.add(s1.pop());
        }
        //注意因为是存放到List, 因此按顺序输出就是对应的后缀表达式对应的List
        return s2;
    }
}

//编写一个类 Operation 可以返回一个运算符 对应的优先级
class Operation {
    private static int ADD = 1;
    private static int SUB = 1;
    private static int MUL = 2;
    private static int DIV = 2;

    //写一个方法，返回对应的优先级数字
    public static int getValue(String operation) {
        int result = 0;
        switch (operation) {
            case "+":
                result = ADD;
                break;
            case "-":
                result = SUB;
                break;
            case "*":
                result = MUL;
                break;
            case "/":
                result = DIV;
                break;
            default:
                System.out.println("不存在该运算符" + operation);
                break;
        }
        return result;
    }

}

```



# 5、递归

## 5.1、递归概念

简单的说: **递归就是方法自己调用自己**,每次调用时**传入不同的变量**.递归有助于编程者解决复杂的问题,同时 可以让代码变得简洁。

## 5.2、递归调用机制

![image-20210802231322949](C:\Users\pz\AppData\Roaming\Typora\typora-user-images\image-20210802231322949.png)

## 5.3、递归-迷宫问题

给出起点和终点，寻找路径

### 代码实现

```java
package com.lyb.recursion;

/**
 * Created with IntelliJ IDEA.
 * User: pz
 * Date: 2021/8/2
 * Time: 22:54
 * Description: No Description
 */
public class MiGong {
    public static void main(String[] args) {

        //创建二维数组，模拟地图
        int[][] map = new int[8][7];
        //1表示墙
        //设置墙
        for (int i = 0;i<7;i++){
            map[0][i] = 1;
            map[7][i] = 1;
        }
        for (int i = 0; i < 8; i++) {
            map[i][0] = 1;
            map[i][6] = 1;
        }
//        //测试回溯
//        for (int i = 0; i < 7; i++) {
//            map[3][i] =1;
//        }

        //挡板
        map[3][1] = 1;
        map[3][2] = 1;

        //输出地图
        System.out.println("地图");
        for (int i = 0; i < 8; i++){
            for (int j = 0;j<7;j++){
                System.out.print(map[i][j]+" ");
            }
            System.out.println();
        }

        setWay(map,1,1);

        System.out.println("地图");
        for (int i = 0; i < 8; i++){
            for (int j = 0;j<7;j++){
                System.out.print(map[i][j]+" ");
            }
            System.out.println();
        }

    }

    /**
     *	//使用递归回溯来给小球找路
     * 	//说明
     * 	//1. map 表示地图
     * 	//2. i,j 表示从地图的哪个位置开始出发 (1,1)
     * 	//3. 如果小球能到 map[6][5] 位置，则说明通路找到.
     * 	//4. 约定： 当map[i][j] 为 0 表示该点没有走过 当为 1 表示墙  ； 2 表示通路可以走 ； 3 表示该点已经走过，但是走不通
     * 	//5. 在走迷宫时，需要确定一个策略(方法) 下->右->上->左 , 如果该点走不通，再回溯
     *
     *
     * @param map 地图
     * @param i 初始行
     * @param j 初始列
     * @return 如果找到通路，就返回true, 否则返回false
     */
    public static boolean setWay(int[][] map,int i,int j){

        if (map[6][5]==2){//找到通路
            return true;
        }else {
            if (map[i][j] == 0){
                //策略 下->右->上->左
                map[i][j]=2;//假定该点是可以走通.
                if (setWay(map,i+1,j)){//向下
                    return true;
                }else if (setWay(map,i,j+1)){
                    return true;
                }else if (setWay(map,i-1,j)){
                    return true;
                }else if (setWay(map,i,j-1)){
                    return true;
                }else {
                    map[i][j] = 3;
                    return false;
                }
            }else { // 如果map[i][j] != 0 , 可能是 1， 2， 3
                return false;
            }
        }
    }
}

```



